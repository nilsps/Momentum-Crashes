---
title: "Calculation of portfolios"
output: html_notebook
---

```{r}
library(tidyquant)
library(tidyverse)
library(dplyr)
library(plyr)
library(slider)
```

```{r}
  library(doParallel)
  library(snow)
  library(doSNOW)
cl <- makeCluster(detectCores()-1, type = "SOCK")
 
call_cluster_init = function(cl){
 registerDoParallel(cl)
}
```

```{r}
lapply(df, class) # Checking if every Col is in order

df$ranking_start = df$date %m-% months(12)

day(df$ranking_start) = days_in_month(df$ranking_start) #Se day of data to last day of month

df$ranking_end = df$date %m-% months(2) # Per MC paper subtract two months

day(df$ranking_end) = days_in_month(df$ranking_end) # set day of the date = last day of the month

```

<!-- ```{r, warning=FALSE} -->


<!-- #skal ikke behÃ¸ve og ha loop  -->
<!-- for (i in 1:length(dfa)) {  -->
<!--   x = unique(dfa$ranking_start %m+% years(1)) -->
<!--   for ( j in 1:length(dfa)) { -->
<!--     if (dfa$date == x){ -->
<!--       print("yay")} -->
<!--   } -->
<!-- } -->
<!-- ``` -->


```{r}
df = data.table::data.table(df)

dfa = df # Just making a file to work with
dfa[is.na(dfa)] = 0 #set nas' to zero

gaps= c(1,7,30) # daily, weekly, monthly, return

dfa = dfa %>% group_by(symbol) %>% arrange(date) #Ordering and sorting the data 

returns = function(gaps){(df$close - lead(df$close, n= gaps)) / lead(df$close,n = gaps)} # Return function

rets = as.data.frame(lapply(gaps,returns)) # Run function on the gaps to get returns

colnames(rets)[1] <- "d_ret" # Renaming cols 
colnames(rets)[2] <- "w_ret"
colnames(rets)[3] <- "m_ret"

df_temp = dfa %>% # Adding cumalative returns
  mutate(cr = cumprod(1 + rets$d_ret)) 

dfa = cbind(dfa, d_ret = rets[1], w_ret = rets[2], m_ret = rets[3], cr = df_temp$cr) # binding all calculated data to dfa

head(dfa) # Checking the DFA to make sure we got everything we need

```

# ```{r}
# v= tapply(df$date, as.yearmon(df$date), max)
#
# z = tapply(df$date, substr(df$date, 1, 7), max)
# ```



```{r}
# goal is to check for monthly 8 monthly returns over 11 month 

# gaps= c(1,7,30) # daily, weekly, monthly, return
# 
# dfa = dfa %>% group_by(symbol) %>% arrange(date) #Ordering and sorting the data 
# 
# returns = function(gaps){(df$close - lead(df$close, n= gaps)) / lead(df$close,n = gaps)} # Return function
# 
# rets = as.data.frame(lapply(gaps,returns))

dfa$shifted_date<-dfa$date %m+% months(1) # Making a column with +1 month shift as of the time lag needed for formations date
```


```{r}
#names(dfa)[names(dfa) == "close"] = "close.x"

x = c("symbol", "shifted_date", "m_ret")
return_cols = c()

for(i in c(2:12)){ # We calculate from 2 months to twelve = 8 months 
    dfa$shifted_date = dfa$date %m+% months(i) # shift by i months
    day(dfa$shifted_date) = days_in_month(dfa$shifted_date) # Provides shift date with end of month
    
    dfa<-merge(df, # merge return using the shifted date
                     (dfa[,..(symbol, shifted_date, m_ret )]),
                     by.x=c("symbol", "date"),
                     by.y=c("symbol", "shifted_date"),
                     all.x=TRUE
                     )
    
    names(df)[names(df) == "m_ret.x"] <- "m_ret" # correct the column names
    names(df)[names(df) == "m_ret.y"] <-paste0("m_ret_m-", i)
    return_cols<-c(return_cols, paste0("m_ret_m-", i))
}
```


```{r}
return_cols = c() # Empty vector
packs_needed = c("tidyquant") # Packages needed for th for each loop

call_cluster_init() # Initiate the cluster for parallel computing


foreach(i = 2:12, .packages = packs_needed) %dopar%  {
    dfa$shifted_date = dfa$date %m+% months(i) # shift by i months
    day(dfa$shifted_date) = days_in_month(dfa$shifted_date)
    
    df = merge(df, # merge return using the shifted date
                     dfa[,.(symbol, shifted_date, d_return)],
                     by.x=c("symbol", "date"),
                     by.y=c("symbol", "shifted_date"),
                     all.x=TRUE
                     )
    
    names(df)[names(df) == "return.x"] <- "return" # correct the column names
    names(df)[names(df) == "return.y"] <-paste0("return_m", i)
    return_cols = c(return_cols, paste0("return_m", i))
} 

stopCluster(cl)

df
return_cols
stockdata$available_returns<-rowSums(!is.na(stockdata[,return_cols, with=FALSE])) # compute no of available returns
stockdata
```



