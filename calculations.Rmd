---
title: "Calculation of portfolios"
output: html_notebook
---

```{r}
library(tidyquant)
library(tidyverse)
library(dplyr)
library(plyr)
library(slider)
library(bsts)
library(matrixStats)
```

# ```{r}
#   library(doParallel)
#   library(snow)
#   library(doSNOW)
# cl <- makeCluster(detectCores()-1, type = "SOCK")
#  
# call_cluster_init = function(cl){
#  registerDoParallel(cl)
# }
# ```

```{r}
#load("~/Machinelearning1/Momentum-Crashes/df.Rdata")

df = subset(df, select = -c(open, high, low, volume)) #Removing redundant information

###
## CREATING A MONTHLY DATASET ! 
##

lapply(df, class) # Checking if every Col is in order

month_day = LastDayInMonth(df$date)

df = df %>% filter(date == month_day) 

df$ranking_start = df$date %m-% months(12)

day(df$ranking_start) = days_in_month(df$ranking_start) #Se day of data to last day of month

df$ranking_end = df$date %m-% months(2) # Per MC paper subtract two months

day(df$ranking_end) = days_in_month(df$ranking_end) # set day of the date = last day of the month

dfa= data.table::data.table(df) #making a "working" table
dfa$shifted_date<-dfa$date %m+% months(1)
day(dfa$shifted_date)<-days_in_month(dfa$shifted_date)

dfa[is.na(dfa)] = 0 #set nas' to zero
```

<!-- ```{r, warning=FALSE} -->


<!-- #skal ikke behÃ¸ve og ha loop  -->
<!-- for (i in 1:length(dfa)) {  -->
<!--   x = unique(dfa$ranking_start %m+% years(1)) -->
<!--   for ( j in 1:length(dfa)) { -->
<!--     if (dfa$date == x){ -->
<!--       print("yay")} -->
<!--   } -->
<!-- } -->
<!-- ``` -->


```{r}
dfa[is.na(dfa)] = 0 #set nas' to zero

gaps= c(1) #c(1,7,30) # daily, weekly, monthly, return #### SET TO ONE AS THIS IS MONTHLY DATASET

dfa = dfa %>% group_by(symbol) %>% arrange(date) #Ordering and sorting the data 

returns = function(gaps){(df$close - lead(df$close, n= gaps)) / lead(df$close,n = gaps)} # Return function

rets = as.data.frame(lapply(gaps,returns)) # Run function on the gaps to get returns

#colnames(rets)[1] <- "d_ret" # Renaming cols 
#colnames(rets)[2] <- "w_ret"
colnames(rets)[1] <- "m_ret"

df_temp = dfa %>% # Adding cumalative returns
  mutate(cr = cumprod(1 + rets$m_ret)) 

#dfa = cbind(dfa, d_ret = rets[1], w_ret = rets[2], m_ret = rets[3], cr = df_temp$cr) # binding all calculated data to dfa

dfa = cbind(dfa, d_ret = rets[1], cr = df_temp$cr) 

head(dfa) # Checking the DFA to make sure we got everything we need


```

# ```{r}
# v= tapply(df$date, as.yearmon(df$date), max)
#
# z = tapply(df$date, substr(df$date, 1, 7), max)
# ```



```{r}
# goal is to check for monthly 8 monthly returns over 11 month 

# gaps= c(1,7,30) # daily, weekly, monthly, return
# 
# dfa = dfa %>% group_by(symbol) %>% arrange(date) #Ordering and sorting the data 
# 
# returns = function(gaps){(df$close - lead(df$close, n= gaps)) / lead(df$close,n = gaps)} # Return function
# 
# rets = as.data.frame(lapply(gaps,returns))

#dfa$shifted_date<-dfa$date %m+% months(1) # Making a column with +1 month shift as of the time lag needed for formations date
```


```{r}
#names(dfa)[names(dfa) == "close"] = "close.x"

x = c("symbol", "shifted_date", "m_ret")
return_cols = c()

packs_needed = c("dplyr", "tidyverse")

foreach(i = 2:12, .packages = packs_needed){ # eleven months
    dfa$shifted_date = dfa$date %m+% months(i) # shift by i months
    day(dfa$shifted_date) = days_in_month(dfa$shifted_date) # Provides shift date with end of month
    
    df = merge(df, # merge return using the shifted date
                     dfa[x],
                     by.x=c("symbol", "date"),
                     by.y=c("symbol", "shifted_date"),
                     all.x=TRUE
                     )
    
    names(df)[names(df) == "m_ret.x"] <- "m_ret" # correct the column names
    names(df)[names(df) == "m_ret.y"] <-paste0("m_ret", i)
    return_cols<-c(return_cols, paste0("m_ret", i))
}

df
return_cols
df$available_returns = rowSums(!is.na(df[,return_cols[2:11]])) # compute no of available returns
df

dfa=NULL
df$cum_return=rowProds(1+as.matrix(df[,return_cols[2:11]]), na.rm=T) # compute cumulative product

df

df = df[, -c(8:17)] # WARNING HARD CODED!  

#df<-df[, !return_cols[2:11]] # drop return_cols (not needed anymore)
return_cols=NULL
df_temp = NULL
rets = NULL
month_day = NULL
glimpse(df)
```


```{r}
library(data.table)
dfa = df

# remove rows which have available_returns < 8
dfa = dfa %>% filter(available_returns >= 8)
glimpse(dfa)

# normalize using the number of available returns
dfa$cum_return = dfa$cum_return / dfa$available_returns
# cut returns for each date into deciles to determine winner/loser portfolios
 
dfa$quantile = cut(dfa$cum_return,
    quantile(dfa$cum_return,probs=seq(from=0,to=1,by=1/10),na.rm =T),
    include.lowest=TRUE, 
    labels=FALSE)

top = dfa %>% filter(quantile == 10)
top = top %>% arrange(date) 
top$cr_ret = top$close - lead(top$close) / lead(top$close)

bot = dfa %>% filter(quantile == 1)

quant_portf = merge (bot, top, by.x = "date", by.y = "date")

ggplot(top, aes(x = date)) +
       theme(legend.position = "top") +
       geom_smooth(aes(y = cr_ret), color = "darkred") + 
       labs(x = 'Date',
       y = 'Cumulative Returns',
       title = 'Portfolio Cumulative Returns') +
    scale_y_continuous(breaks = seq(0,1300000,100000)) +
    scale_x_date()#date_breaks = '10 year',
               #date_labels = '%Y')

```



